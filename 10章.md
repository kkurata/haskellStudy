###10章 関数型問題解決法
- ## 初めに
 - この章で説明していることは（おそらく）現実問題をいかに関数に落とし込んで解くか？ということ。
 - そのための具体例として、「逆ポーランド記法電卓の実装」「最短経路探索問題」をhaskellを使って表現している。
 - ということでそれらについて紹介

- ## 10.1 逆ポーランド記法電卓 
 - RPN記法  : 数をスタックしていくようなイメージの計算記法。具体的には4 + 3を4 3 +のように記述する。中置記法に比べて、パッと見の計算がわかりずらいが、演算子の優先順位を括弧等で指定する必要がない！ 
   - 例 10 4 3 + 2 * - →10 7 2 * - →10 14 - → -4 
    - これと等しい中置記法での表現は10 -( ( 4 + 3 ) * 2)となり、括弧が2組減っていることが分かる！
    
 - RPN関数(solveRPN) : 逆ポーランド記法を計算する関数
  - まず型から考えると、文字列をもらって数を出力したいので、solveRPN : String -> Double　とする(割り算したいのでDouble)。
  - スタックを使って考えたいので、文字列をリストに変換（最初からリストで入力したほうがいい気が・・・）
  - リストの先頭から要素をとってきて、演算子をとってきたら、それまでの要素を使って計算する・・・左畳み込みを使う！
  
  ```
  import Data.List
  solveRPN :: (Num a) => String -> a  
  solveRPN expression = head (foldl foldingFunction [] (words expression))
  where   foldingFunction stack item = ...  
  ```
 
  のように実装するのが理想
  - あとは肝心の計算部分。パターンマッチを使って要素に応じて場合分けする。
  - どうせなのでいろいろ一気に実装(ポイントフリースタイルも使って見やすくしている)
  ```
  import Data.List  
  solveRPN :: String -> Float  
  solveRPN = head . foldl foldingFunction [] . words  
    where   foldingFunction (x:y:ys) "*" = (x * y):ys  
            foldingFunction (x:y:ys) "+" = (x + y):ys  
            foldingFunction (x:y:ys) "-" = (y - x):ys  
            foldingFunction (x:y:ys) "/" = (y / x):ys  
            foldingFunction (x:y:ys) "^" = (y ** x):ys  
            foldingFunction (x:xs) "ln" = log x:xs  
            foldingFunction xs "sum" = [sum xs]  
            foldingFunction xs numberString = read numberString:xs 
  ```
  - 感想として、まじめに場合分けすると割とめんどくさい (特に引き算、割り算、べき乗はxとyの順序を意識しないと危ない)
- ## 10.2 ヒースロー空港からロンドンへ
 - 俗に言う最短経路探索問題を解く関数を作ってみる
 - ポイントは、問題をどう形式化するか？どういうアルゴリズムで解く？の2点


###まとめ(1章から6章)- ## 1章　  - 関数    - 前置関数 : 関数の後に引数を置いて使う関数    ```    ghci> max 100 101      101    ```    - 中置関数 : 関数を引数で挟んで使う関数(+や-)    ```    ghci> 92 `div` 10    9    ```    - if文    ```    doubleSmallNumber x = if x > 100                          then x                          else x*2       ```    注意 : elseは必須　ifは必ず値を返す式    - haskellは関数は原則大文字で始めない→型が大文字で表現されているから？    - 関数が引数を持たないとき、定義や名前と呼ぶ    ```    conanO'Brien = "It's a-me, Conan O'Brien!"    ```  - リスト    - リストは＋＋で連結(文字列もできる！)    ```    ghci> [1,2,3,4] ++ [9,10,11,12]      [1,2,3,4,9,10,11,12]      ghci> "hello" ++ " " ++ "world"      "hello world"      ghci> ['w','o'] ++ ['o','t']      "woot"     ```    - consは：で扱える→5:[1,2,3]の結果は[5,1,2,3]となる    - リスト !! index番号でリストにアクセス→[5,1,2,3] !! 2の結果は2    - リストの比較は要素を取り出さなくてもできる！    ```    ghci> [3,2,1] > [2,1,0]      True      ghci> [3,2,1] > [2,10,100]      True      ghci> [3,4,2] > [3,4]      True      ghci> [3,4,2] > [2,4]      True      ghci> [3,4,2] == [3,4,2]      True      ```    - head tail last initの4つのリスト操作も便利？→⁬空リストはエラーを返すので注意    - length,null,reverse,take,drop,maximum,minimum,sum,product,elemとかいろいろあるのでリスト関係で参考に・・・  - レンジ    - [1..20]とかかっこいいよね(間の.は2つに限定、アルファベットも扱える！)    ```    ghci> [1..20]      [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]      ghci> ['a'..'z']      "abcdefghijklmnopqrstuvwxyz"     ```    - [13,26..13*24]とかもいける！    - 遅延評価だから無限リストも使える    - 浮動小数点に弱いので注意（なんかバグる）    ```    ghci> [0.1, 0.3 .. 1]      [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]    ```
